// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nfmessage/common/SearchExpression.proto

package common // import "com/dbproxy/nfmessage/common"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SearchExpression struct {
	// Types that are valid to be assigned to Data:
	//	*SearchExpression_AndExpression
	//	*SearchExpression_OrExpression
	Data                 isSearchExpression_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SearchExpression) Reset()         { *m = SearchExpression{} }
func (m *SearchExpression) String() string { return proto.CompactTextString(m) }
func (*SearchExpression) ProtoMessage()    {}
func (*SearchExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_SearchExpression_7e531ef8918e9653, []int{0}
}
func (m *SearchExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchExpression.Unmarshal(m, b)
}
func (m *SearchExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchExpression.Marshal(b, m, deterministic)
}
func (dst *SearchExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchExpression.Merge(dst, src)
}
func (m *SearchExpression) XXX_Size() int {
	return xxx_messageInfo_SearchExpression.Size(m)
}
func (m *SearchExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchExpression.DiscardUnknown(m)
}

var xxx_messageInfo_SearchExpression proto.InternalMessageInfo

type isSearchExpression_Data interface {
	isSearchExpression_Data()
}

type SearchExpression_AndExpression struct {
	AndExpression *AndExpression `protobuf:"bytes,1,opt,name=and_expression,json=andExpression,proto3,oneof"`
}

type SearchExpression_OrExpression struct {
	OrExpression *ORExpression `protobuf:"bytes,2,opt,name=or_expression,json=orExpression,proto3,oneof"`
}

func (*SearchExpression_AndExpression) isSearchExpression_Data() {}

func (*SearchExpression_OrExpression) isSearchExpression_Data() {}

func (m *SearchExpression) GetData() isSearchExpression_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SearchExpression) GetAndExpression() *AndExpression {
	if x, ok := m.GetData().(*SearchExpression_AndExpression); ok {
		return x.AndExpression
	}
	return nil
}

func (m *SearchExpression) GetOrExpression() *ORExpression {
	if x, ok := m.GetData().(*SearchExpression_OrExpression); ok {
		return x.OrExpression
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SearchExpression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SearchExpression_OneofMarshaler, _SearchExpression_OneofUnmarshaler, _SearchExpression_OneofSizer, []interface{}{
		(*SearchExpression_AndExpression)(nil),
		(*SearchExpression_OrExpression)(nil),
	}
}

func _SearchExpression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SearchExpression)
	// data
	switch x := m.Data.(type) {
	case *SearchExpression_AndExpression:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AndExpression); err != nil {
			return err
		}
	case *SearchExpression_OrExpression:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrExpression); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SearchExpression.Data has unexpected type %T", x)
	}
	return nil
}

func _SearchExpression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SearchExpression)
	switch tag {
	case 1: // data.and_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AndExpression)
		err := b.DecodeMessage(msg)
		m.Data = &SearchExpression_AndExpression{msg}
		return true, err
	case 2: // data.or_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ORExpression)
		err := b.DecodeMessage(msg)
		m.Data = &SearchExpression_OrExpression{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SearchExpression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SearchExpression)
	// data
	switch x := m.Data.(type) {
	case *SearchExpression_AndExpression:
		s := proto.Size(x.AndExpression)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SearchExpression_OrExpression:
		s := proto.Size(x.OrExpression)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AndExpression struct {
	MetaExpression       []*MetaExpression `protobuf:"bytes,1,rep,name=meta_expression,json=metaExpression,proto3" json:"meta_expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AndExpression) Reset()         { *m = AndExpression{} }
func (m *AndExpression) String() string { return proto.CompactTextString(m) }
func (*AndExpression) ProtoMessage()    {}
func (*AndExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_SearchExpression_7e531ef8918e9653, []int{1}
}
func (m *AndExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AndExpression.Unmarshal(m, b)
}
func (m *AndExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AndExpression.Marshal(b, m, deterministic)
}
func (dst *AndExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AndExpression.Merge(dst, src)
}
func (m *AndExpression) XXX_Size() int {
	return xxx_messageInfo_AndExpression.Size(m)
}
func (m *AndExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_AndExpression.DiscardUnknown(m)
}

var xxx_messageInfo_AndExpression proto.InternalMessageInfo

func (m *AndExpression) GetMetaExpression() []*MetaExpression {
	if m != nil {
		return m.MetaExpression
	}
	return nil
}

type ORExpression struct {
	MetaExpression       []*MetaExpression `protobuf:"bytes,1,rep,name=meta_expression,json=metaExpression,proto3" json:"meta_expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ORExpression) Reset()         { *m = ORExpression{} }
func (m *ORExpression) String() string { return proto.CompactTextString(m) }
func (*ORExpression) ProtoMessage()    {}
func (*ORExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_SearchExpression_7e531ef8918e9653, []int{2}
}
func (m *ORExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ORExpression.Unmarshal(m, b)
}
func (m *ORExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ORExpression.Marshal(b, m, deterministic)
}
func (dst *ORExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ORExpression.Merge(dst, src)
}
func (m *ORExpression) XXX_Size() int {
	return xxx_messageInfo_ORExpression.Size(m)
}
func (m *ORExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ORExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ORExpression proto.InternalMessageInfo

func (m *ORExpression) GetMetaExpression() []*MetaExpression {
	if m != nil {
		return m.MetaExpression
	}
	return nil
}

type MetaExpression struct {
	// Types that are valid to be assigned to Data:
	//	*MetaExpression_SearchParameter
	//	*MetaExpression_AndExpression
	//	*MetaExpression_OrExpression
	Data                 isMetaExpression_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetaExpression) Reset()         { *m = MetaExpression{} }
func (m *MetaExpression) String() string { return proto.CompactTextString(m) }
func (*MetaExpression) ProtoMessage()    {}
func (*MetaExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_SearchExpression_7e531ef8918e9653, []int{3}
}
func (m *MetaExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaExpression.Unmarshal(m, b)
}
func (m *MetaExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaExpression.Marshal(b, m, deterministic)
}
func (dst *MetaExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaExpression.Merge(dst, src)
}
func (m *MetaExpression) XXX_Size() int {
	return xxx_messageInfo_MetaExpression.Size(m)
}
func (m *MetaExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaExpression.DiscardUnknown(m)
}

var xxx_messageInfo_MetaExpression proto.InternalMessageInfo

type isMetaExpression_Data interface {
	isMetaExpression_Data()
}

type MetaExpression_SearchParameter struct {
	SearchParameter *SearchParameter `protobuf:"bytes,1,opt,name=search_parameter,json=searchParameter,proto3,oneof"`
}

type MetaExpression_AndExpression struct {
	AndExpression *AndExpression `protobuf:"bytes,2,opt,name=and_expression,json=andExpression,proto3,oneof"`
}

type MetaExpression_OrExpression struct {
	OrExpression *ORExpression `protobuf:"bytes,3,opt,name=or_expression,json=orExpression,proto3,oneof"`
}

func (*MetaExpression_SearchParameter) isMetaExpression_Data() {}

func (*MetaExpression_AndExpression) isMetaExpression_Data() {}

func (*MetaExpression_OrExpression) isMetaExpression_Data() {}

func (m *MetaExpression) GetData() isMetaExpression_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MetaExpression) GetSearchParameter() *SearchParameter {
	if x, ok := m.GetData().(*MetaExpression_SearchParameter); ok {
		return x.SearchParameter
	}
	return nil
}

func (m *MetaExpression) GetAndExpression() *AndExpression {
	if x, ok := m.GetData().(*MetaExpression_AndExpression); ok {
		return x.AndExpression
	}
	return nil
}

func (m *MetaExpression) GetOrExpression() *ORExpression {
	if x, ok := m.GetData().(*MetaExpression_OrExpression); ok {
		return x.OrExpression
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MetaExpression) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MetaExpression_OneofMarshaler, _MetaExpression_OneofUnmarshaler, _MetaExpression_OneofSizer, []interface{}{
		(*MetaExpression_SearchParameter)(nil),
		(*MetaExpression_AndExpression)(nil),
		(*MetaExpression_OrExpression)(nil),
	}
}

func _MetaExpression_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MetaExpression)
	// data
	switch x := m.Data.(type) {
	case *MetaExpression_SearchParameter:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SearchParameter); err != nil {
			return err
		}
	case *MetaExpression_AndExpression:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AndExpression); err != nil {
			return err
		}
	case *MetaExpression_OrExpression:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrExpression); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MetaExpression.Data has unexpected type %T", x)
	}
	return nil
}

func _MetaExpression_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MetaExpression)
	switch tag {
	case 1: // data.search_parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SearchParameter)
		err := b.DecodeMessage(msg)
		m.Data = &MetaExpression_SearchParameter{msg}
		return true, err
	case 2: // data.and_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AndExpression)
		err := b.DecodeMessage(msg)
		m.Data = &MetaExpression_AndExpression{msg}
		return true, err
	case 3: // data.or_expression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ORExpression)
		err := b.DecodeMessage(msg)
		m.Data = &MetaExpression_OrExpression{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MetaExpression_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MetaExpression)
	// data
	switch x := m.Data.(type) {
	case *MetaExpression_SearchParameter:
		s := proto.Size(x.SearchParameter)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MetaExpression_AndExpression:
		s := proto.Size(x.AndExpression)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MetaExpression_OrExpression:
		s := proto.Size(x.OrExpression)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SearchExpression)(nil), "grpc.SearchExpression")
	proto.RegisterType((*AndExpression)(nil), "grpc.AndExpression")
	proto.RegisterType((*ORExpression)(nil), "grpc.ORExpression")
	proto.RegisterType((*MetaExpression)(nil), "grpc.MetaExpression")
}

func init() {
	proto.RegisterFile("nfmessage/common/SearchExpression.proto", fileDescriptor_SearchExpression_7e531ef8918e9653)
}

var fileDescriptor_SearchExpression_7e531ef8918e9653 = []byte{
	// 303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0x31, 0x4f, 0xc2, 0x40,
	0x1c, 0xc5, 0x29, 0x10, 0x86, 0x83, 0x16, 0x72, 0x4a, 0x62, 0x8c, 0x83, 0xe9, 0xa0, 0x4c, 0xd7,
	0x04, 0x27, 0x13, 0x1d, 0x6c, 0x62, 0xc2, 0x82, 0x92, 0xba, 0xb9, 0x90, 0xe3, 0x7a, 0x45, 0x86,
	0xbb, 0x7f, 0xf3, 0xbf, 0x0e, 0xf8, 0x39, 0xfc, 0x6c, 0x7e, 0x1f, 0x43, 0x0f, 0x69, 0xaf, 0xd1,
	0x81, 0x30, 0xde, 0xcb, 0x7b, 0xef, 0x7f, 0xf9, 0xe5, 0x91, 0x5b, 0x9d, 0x29, 0x69, 0x0c, 0x5f,
	0xcb, 0x48, 0x80, 0x52, 0xa0, 0xa3, 0x37, 0xc9, 0x51, 0x7c, 0x3c, 0x6f, 0x73, 0x94, 0xc6, 0x6c,
	0x40, 0xb3, 0x1c, 0xa1, 0x00, 0xda, 0x5d, 0x63, 0x2e, 0x2e, 0x6f, 0xfe, 0xb1, 0x2f, 0x38, 0x72,
	0x25, 0x0b, 0x89, 0xd6, 0x1d, 0x7e, 0x79, 0x64, 0xd4, 0x2c, 0xa2, 0x0f, 0x24, 0xe0, 0x3a, 0x5d,
	0xca, 0x83, 0x72, 0xe1, 0x5d, 0x7b, 0x93, 0xfe, 0xf4, 0x8c, 0xed, 0xba, 0xd9, 0x93, 0x4e, 0x2b,
	0xf3, 0xac, 0x95, 0xf8, 0xbc, 0x2e, 0xd0, 0x7b, 0xe2, 0x03, 0xd6, 0xc3, 0xed, 0x32, 0x4c, 0x6d,
	0xf8, 0x35, 0x71, 0xb2, 0x03, 0xc0, 0xea, 0x1d, 0xf7, 0x48, 0x37, 0xe5, 0x05, 0x0f, 0x5f, 0x88,
	0xef, 0x1c, 0xa1, 0x8f, 0x64, 0xa8, 0x64, 0xc1, 0xdd, 0x2f, 0x75, 0x26, 0xfd, 0xe9, 0xb9, 0x6d,
	0x9d, 0xcb, 0x82, 0x57, 0xf6, 0x24, 0x50, 0xce, 0x3b, 0x9c, 0x93, 0x41, 0xfd, 0xee, 0xa9, 0x75,
	0xdf, 0x1e, 0x09, 0x5c, 0x0b, 0x8d, 0xc9, 0xc8, 0x94, 0x18, 0x97, 0xf9, 0x2f, 0xe1, 0x3d, 0xb4,
	0xb1, 0xad, 0x6c, 0xe0, 0x9f, 0xb5, 0x92, 0xa1, 0x71, 0xa5, 0x3f, 0xb0, 0xb7, 0x4f, 0xc1, 0xde,
	0x39, 0x16, 0x7b, 0x9c, 0x91, 0x48, 0xe2, 0x46, 0x18, 0x03, 0x9a, 0x09, 0x40, 0xc9, 0x34, 0x66,
	0x2c, 0x5d, 0xe5, 0x08, 0xdb, 0x4f, 0x5b, 0x73, 0x58, 0x15, 0xb3, 0xab, 0x8a, 0xc7, 0xcd, 0xf1,
	0x2c, 0x76, 0xb3, 0x7a, 0xbf, 0x12, 0xa0, 0xa2, 0x7d, 0x32, 0x6a, 0x4e, 0x71, 0xd5, 0x2b, 0xb7,
	0x77, 0xf7, 0x13, 0x00, 0x00, 0xff, 0xff, 0xc7, 0x47, 0xdb, 0x0f, 0xd4, 0x02, 0x00, 0x00,
}
